/**
 * Application link service
 * Generates one-time use links for loan applications
 */

import { pb } from '$lib/infra/db/pb';
import {
	Collections,
	ApplicationLinksStatusOptions,
	type ApplicationLinksResponse
} from '$lib/types';
import { NotFoundError, ValidationError, ForbiddenError, ServiceError } from '$lib/shared/errors';
import { calculateLinkExpiryFromMinutes, isExpired, nowISO } from '$lib/shared/date_time';
import { logLinkCreated, logLinkUsed } from '$lib/core/activity/activity_service';
import { assertPermission, type UserPermissions } from '$lib/services/roles/permission_checker';
import { Permission } from '$lib/services/roles/permissions';

// Default link expiry in minutes
const DEFAULT_LINK_EXPIRY_MINUTES = 720;

/**
 * Extract detailed error message from PocketBase ClientResponseError
 */
function extractPocketBaseError(error: unknown): string {
	if (typeof error !== 'object' || error === null) {
		return 'Unknown error occurred';
	}

	const pbError = error as { 
		response?: { 
			message?: string; 
			data?: Record<string, { message?: string; code?: string }> 
		};
		message?: string;
		status?: number;
	};

	if (pbError.response?.data && typeof pbError.response.data === 'object') {
		const fieldErrors = Object.entries(pbError.response.data)
			.map(([field, err]) => {
				if (typeof err === 'object' && err !== null) {
					return `${field}: ${(err as any).message || (err as any).code || JSON.stringify(err)}`;
				}
				return `${field}: ${String(err)}`;
			})
			.join(', ');
		if (fieldErrors) {
			return `Validation failed - ${fieldErrors}`;
		}
	}

	// Check for general response message
	if (pbError.response?.message) {
		return pbError.response.message;
	}

	// Fallback to error message
	if (pbError.message) {
		return pbError.message;
	}

	return 'Failed to create application link';
}

/**
 * Generate a secure random token
 */
function generateToken(): string {
	const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
	const tokenLength = 32;
	let token = '';
	const randomValues = new Uint8Array(tokenLength);
	crypto.getRandomValues(randomValues);
	for (let i = 0; i < tokenLength; i++) {
		token += chars[randomValues[i] % chars.length];
	}
	return token;
}

/**
 * Create application link input
 */
export interface CreateLinkInput {
	customerId?: string;
	expiryMinutes?: number;
}

/**
 * Create a new application link
 * Requires LINKS_CREATE permission
 */
export async function createApplicationLink(
	input: CreateLinkInput,
	userId: string,
	userPermissions: UserPermissions
): Promise<ApplicationLinksResponse> {
	// Check for LINKS_CREATE permission (application-level check)
	assertPermission(userPermissions, Permission.LINKS_CREATE);

	const expiryMinutes = input.expiryMinutes || DEFAULT_LINK_EXPIRY_MINUTES;
	const expiryDate = calculateLinkExpiryFromMinutes(expiryMinutes);

	// Note: token is auto-generated by PocketBase via autogeneratePattern
	// Start with minimal required fields only
	const linkData: Record<string, unknown> = {
		status: ApplicationLinksStatusOptions.unused,
		expires_at: expiryDate.toISOString()
	};

	// Only add optional fields if they have values
	if (userId) {
		linkData.created_by = userId;
	}
	if (input.customerId) {
		linkData.customer = input.customerId;
	}

	try {
		const link = await pb.collection(Collections.ApplicationLinks).create<ApplicationLinksResponse>(linkData);
try {
			await logLinkCreated(link.id, userId, input.customerId);
		} catch (logError) {
			// console.warn('[LinkService] Failed to log link creation:', logError);
		}

		return link;
	} catch (error) {
		const errorMessage = extractPocketBaseError(error);
	

		// Check if it's a permission error from PocketBase (403)
		const pbError = error as { status?: number };
		if (pbError.status === 403) {
			throw new ForbiddenError(
				`Permission denied by database. Ensure your role has 'links_create' permission configured in PocketBase. Error: ${errorMessage}`,
				'links_create'
			);
		}

		// Re-throw with more context
		throw new ServiceError('ApplicationLink', errorMessage);
	}
}

/**
 * Get application link by token
 */
export async function getLinkByToken(token: string): Promise<ApplicationLinksResponse | null> {
	if (!token || token.length < 10) {
		return null;
	}

	try {
		const link = await pb
			.collection(Collections.ApplicationLinks)
			.getFirstListItem<ApplicationLinksResponse>(`token = "${token}"`);
		return link;
	} catch {
		return null;
	}
}

/**
 * Get application link by ID
 */
export async function getLinkById(linkId: string): Promise<ApplicationLinksResponse> {
	try {
		const link = await pb
			.collection(Collections.ApplicationLinks)
			.getOne<ApplicationLinksResponse>(linkId);
		return link;
	} catch {
		throw new NotFoundError('Application link', linkId);
	}
}

/**
 * Validate link status result
 */
export interface LinkValidationResult {
	valid: boolean;
	link: ApplicationLinksResponse | null;
	error?: string;
	errorCode?: 'NOT_FOUND' | 'EXPIRED' | 'USED' | 'INVALID';
}

/**
 * Validate an application link
 */
export async function validateLink(token: string): Promise<LinkValidationResult> {
	const link = await getLinkByToken(token);

	if (!link) {
		return {
			valid: false,
			link: null,
			error: 'Application link not found or invalid',
			errorCode: 'NOT_FOUND'
		};
	}

	// Check if already used
	if (link.status === ApplicationLinksStatusOptions.used) {
		return {
			valid: false,
			link,
			error: 'This application link has already been used',
			errorCode: 'USED'
		};
	}

	// Check if expired
	if (link.status === ApplicationLinksStatusOptions.expired || isExpired(link.expires_at)) {
		// Update status if needed
		if (link.status !== ApplicationLinksStatusOptions.expired) {
			await pb.collection(Collections.ApplicationLinks).update(link.id, {
				status: ApplicationLinksStatusOptions.expired
			});
		}

		return {
			valid: false,
			link,
			error: 'This application link has expired',
			errorCode: 'EXPIRED'
		};
	}

	return {
		valid: true,
		link
	};
}

/**
 * Mark link as used
 */
export async function markLinkAsUsed(
	linkId: string,
	loanId: string,
	ipAddress?: string,
	userAgent?: string
): Promise<ApplicationLinksResponse> {
	const link = await getLinkById(linkId);

	if (link.status !== ApplicationLinksStatusOptions.unused) {
		throw new ForbiddenError('This application link cannot be used');
	}

	const updatedLink = await pb
		.collection(Collections.ApplicationLinks)
		.update<ApplicationLinksResponse>(linkId, {
			status: ApplicationLinksStatusOptions.used,
			used_at: nowISO(),
			loan: loanId,
			ip_address: ipAddress,
			user_agent: userAgent
		});

	// Log activity
	await logLinkUsed(linkId, ipAddress);

	return updatedLink;
}

/**
 * Mark link as expired
 */
export async function expireLink(linkId: string): Promise<ApplicationLinksResponse> {
	return await pb
		.collection(Collections.ApplicationLinks)
		.update<ApplicationLinksResponse>(linkId, {
			status: ApplicationLinksStatusOptions.expired
		});
}

/**
 * Get all links created by a user
 */
export async function getLinksByCreator(
	userId: string,
	userPermissions: UserPermissions
): Promise<ApplicationLinksResponse[]> {
	assertPermission(userPermissions, Permission.LOANS_VIEW);

	const result = await pb
		.collection(Collections.ApplicationLinks)
		.getFullList<ApplicationLinksResponse>({
			filter: `created_by = "${userId}"`,
			sort: '-created'
		});

	return result;
}

/**
 * Get recent application links
 */
export async function getRecentLinks(
	limit: number = 50,
	userPermissions: UserPermissions
): Promise<ApplicationLinksResponse[]> {
	assertPermission(userPermissions, Permission.LOANS_VIEW);

	const result = await pb
		.collection(Collections.ApplicationLinks)
		.getList<ApplicationLinksResponse>(1, limit, {
			sort: '-created',
			expand: 'created_by,customer,loan'
		});

	return result.items;
}

/**
 * Cleanup expired links (for cron job)
 */
export async function cleanupExpiredLinks(): Promise<number> {
	const now = new Date().toISOString();

	// Find unused links that have passed expiry
	const expiredLinks = await pb
		.collection(Collections.ApplicationLinks)
		.getFullList<ApplicationLinksResponse>({
			filter: `status = "${ApplicationLinksStatusOptions.unused}" && expires_at < "${now}"`
		});

	// Update each to expired status
	for (const link of expiredLinks) {
		await pb.collection(Collections.ApplicationLinks).update(link.id, {
			status: ApplicationLinksStatusOptions.expired
		});
	}

	return expiredLinks.length;
}

/**
 * Build full application URL from token
 */
export function buildApplicationUrl(token: string, baseUrl: string): string {
	return `${baseUrl}/apply?token=${token}`;
}

/**
 * Get link statistics
 */
export async function getLinkStats(userPermissions: UserPermissions): Promise<{
	total: number;
	unused: number;
	used: number;
	expired: number;
}> {
	assertPermission(userPermissions, Permission.ANALYTICS_VIEW);

	const [total, unused, used, expired] = await Promise.all([
		pb.collection(Collections.ApplicationLinks).getList(1, 1),
		pb.collection(Collections.ApplicationLinks).getList(1, 1, {
			filter: `status = "${ApplicationLinksStatusOptions.unused}"`
		}),
		pb.collection(Collections.ApplicationLinks).getList(1, 1, {
			filter: `status = "${ApplicationLinksStatusOptions.used}"`
		}),
		pb.collection(Collections.ApplicationLinks).getList(1, 1, {
			filter: `status = "${ApplicationLinksStatusOptions.expired}"`
		})
	]);

	return {
		total: total.totalItems,
		unused: unused.totalItems,
		used: used.totalItems,
		expired: expired.totalItems
	};
}
